{"meta":{"title":"山外小楼","subtitle":"前端攻略","description":"我是萌新","author":"萌新","url":"http://iyue.top"},"pages":[{"title":"分类","date":"2018-07-16T07:25:27.000Z","updated":"2018-08-21T02:53:20.608Z","comments":false,"path":"categories/index.html","permalink":"http://iyue.top/categories/index.html","excerpt":"","text":""},{"title":"关于","date":"2018-08-12T06:34:55.000Z","updated":"2018-08-12T06:35:59.368Z","comments":true,"path":"about/index.html","permalink":"http://iyue.top/about/index.html","excerpt":"","text":""},{"title":"标签","date":"2018-07-16T07:24:04.000Z","updated":"2018-08-21T02:53:11.175Z","comments":false,"path":"tags/index.html","permalink":"http://iyue.top/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"post请求的提交数据的几种方式","slug":"post请求的提交数据的几种方式","date":"2018-09-05T12:00:13.000Z","updated":"2018-09-06T01:46:56.926Z","comments":true,"path":"2018/09/05/post请求的提交数据的几种方式/","link":"","permalink":"http://iyue.top/2018/09/05/post请求的提交数据的几种方式/","excerpt":"","text":"前言HTTP/1.1 协议规定的 HTTP 请求方法有 OPTIONS、GET、HEAD、POST、PUT、DELETE、TRACE、CONNECT 这几种。其中 POST 一般用来向服务端提交数据，本文主要讨论 POST 提交数据的几种方式。我们知道，HTTP 协议是以 ASCII 码传输，建立在 TCP/IP 协议之上的应用层规范。规范把 HTTP 请求分为三个部分：状态行、请求头、消息主体。协议规定 POST 提交的数据必须放在消息主体（entity-body）中，但协议并没有规定数据必须使用什么编码方式。实际上，开发者完全可以自己决定消息主体的格式，只要最后发送的 HTTP 请求满足上面的格式就可以。但是，数据发送出去，还要服务端解析成功才有意义。一般服务端语言如 php、python 等，以及它们的 framework，都内置了自动解析常见数据格式的功能。服务端通常是根据请求头（headers）中的 Content-Type 字段来获知请求中的消息主体是用何种方式编码，再对主体进行解析。所以说到 POST 提交数据方案，包含了 Content-Type 和消息主体编码方式两部分。下面就正式开始介绍它们。 个人理解：get请求其实就是将参数以key=value&amp;key=value的形式拼在url发往服务器，所以get请求没有那么多复杂的说法；而post请求规定提交的数据必须放在消息主体（entity-body）中，但没有对形式的规定，所以就有了各种各样的方式； 引出问题123456789101112131415161718192021var ajax = new XMLHttpRequest();var data1 = '&#123;\"arr\":[1,2,3,4,5],\"test\":\"name\"&#125;'var data2 = 'name=jack&amp;age=998'// 使用post请求ajax.open('post', 'http://localhost:8000/api/test/');// 如果 使用post发送数据 必须 设置 如下内容// 修改了 发送给 服务器的 请求报文的 内容// 如果需要像 HTML 表单那样 POST 数据，请使用 setRequestHeader() 来添加 HTTP 头。然后在 send() 方法中规定您希望发送的数据：ajax.setRequestHeader(\"Content-type\", \"application/x-www-form-urlencoded\");// 发送// post请求 发送的数据 写在 send方法中// 格式 name=jack&amp;age=18 字符串的格式;不能直接发送一个对象，否则后端会变成[object Object]ajax.send(data);// 注册事件ajax.onreadystatechange = function () &#123; if (ajax.readyState == 4 &amp;&amp; ajax.status == 200) &#123; console.log(ajax.responseText); &#125;&#125; 需要注意的是，ajax.send()的内容可以是data1的格式（JSON.stringfy()得来），也可以是data2的格式（qs.stringfy()得来），两种的方式都可以； 另外ajax.send()不能直接发送对象，后端接受会变成[object Object]，而对于axios库，直接发送对象，它会自动转成json字符串； 在后端为django的代码中测试123456789101112def test(request): if request.method == 'POST': print request.POST.get('arr') print request.body data = &#123; 'code': 0, 'msg': 'this is a test', 'data': 'POST' &#125; rep = HttpResponse(json.dumps(data, cls=CJsonEncoder), content_type=\"application/json\") rep.set_cookie('key', 'value001') return rep 如何是data1的格式就是json字符串的话，request.POST是无法获取到东西的，data2格式通过request.POST是可以获取到的，但前提是请求的Content-type必须设置为application/x-www-form-urlencoded,否则都获取不到结果，只能从request.body中获得原始数据；之所以这样是因为django框架在处理响应时，只对Content-type为application/x-www-form-urlencoded的情况做了处理，（具体可以查看django的源码中class HttpRequest(object)对post的处理部分）django之所以这么做，是因为什么呢？下面先说一下关于post的几种请求方式 application/x-www-form-urlencoded这是post的默认请求方式，在post请求不设置Content-type时的默认值；123456&lt;form action=\"http://localhost:8000/api/test/\" method=\"post\"&gt; First name:&lt;br&gt; &lt;input type=\"text\" name=\"firstname\" value=\"Mickey\"&gt;&lt;br&gt; Last name:&lt;br&gt; &lt;input type=\"text\" name=\"lastname\" value=\"Mouse\"&gt;&lt;br&gt;&lt;br&gt; &lt;input type=\"submit\" value=\"提交\"&gt;&lt;/form&gt; 这也是原始提交表单的方式，在表单提交的方式里，浏览器会把表单里的数据，以key=value&amp;key=value的形式发送给服务器；个人理解，由于这种最初的提交方式,决定了application/x-www-form-urlencoded下对数据的处理;所以，在ajax请求的年代，其实传哪种（data1和data2）格式都可以，不同的是，服务器是以Content-type的类型来决定如何处理数据的；结论：这种post的类型的时候可以向服务器发送数据，而数据的格式应为键值对key=value&amp;key=value，js对象可以通过qs.stringfy()来序列化得到 application/json这种方式就是告诉服务器，传输的数据为json字符串，所以对应的数格式应为json字符串，js对象可以通过JSON.stringfy()来序列化得到；这是一种略新的格式，可能早期的ie等浏览器不支持 multipart/form-data这种类型主要用来上传文件（可上传多个），也可以发送键值对；（该内容后续展开） text/plain (text/json/xml/html)数据以纯文本形式(text/json/xml/html)进行编码，其中不含任何控件或格式字符。postman软件里标的是RAW,application/json包含在RAW里； binary暂没用过，只在postman中看到过，相当于Content-Type:application/octet-stream,从字面意思得知，只可以上传二进制数据，通常用来上传文件，由于没有键值，所以，一次只能上传一个文件。","categories":[],"tags":[]},{"title":"js变量在内存的存放解惑","slug":"js变量在内存的存放解惑","date":"2018-08-24T11:56:56.000Z","updated":"2018-08-27T07:07:45.583Z","comments":true,"path":"2018/08/24/js变量在内存的存放解惑/","link":"","permalink":"http://iyue.top/2018/08/24/js变量在内存的存放解惑/","excerpt":"","text":"js变量的类型我们知道js变量有两种类型 基本类型值，指简单的数据段，对于undefined、null、boolean、number、string这5种简单数据类型可以直接操作保存在变量中的实际值，也就是按值访问。 引用类型值，指那些可能由多个值构成的对象，只能操作对象的引用而不是实际的对象，所以要得到引用类型这种值只能按引用访问。 变量的存放方式有如下代码段（赋值基本类型）12var a=1;var b=1; 上述代码定义了两个变量，定义a=1在栈内存开辟一块空间存放1这个值，同理定义b=1也开辟一块内存存放1这个值；当修改变量的值的时候，比如重新赋值a=3，那么就会重新开辟一块内存，将3存入后，把a指向3所在的内存位置； 有个问题还没考证，就是不同的变量定义的值一样的时候，是不是指向的是同一块内存。在python中可以通过id来访问存放位置的id，在值（基本类型）较小的时候，就是指向同一块内存 有如下代码段（赋值引用类型）12var c=&#123;name:'阿Q'&#125;;var d=&#123;name:'阿Q'&#125;; 上述代码定义了两个变量，定义c的时候在栈内存开辟一块空间存放一个内存地址，这个内存地址指向堆内存中放{name:&#39;阿Q&#39;}这个对象的内存；d同样如此，而且两个对象是毫无关系的，他们的内存地址是不一样的。当修改变量的值的时候，如c={name:&#39;老王&#39;}，这种情况就和基本类型一样，属于重新赋值，就会将对象{name:&#39;老王&#39;}存到堆内存中，将对象的地址存到栈内存中，c指向这个内存；当修改变量，如c.name=&#39;老张&#39;，这种情况可以看作给对象做一个修正或者扩展，不属于重新赋值，虽然结果是修改了对象，但并没有改动对象所在的位置，即c指向的栈内存里存放的对象的地址并没有变；当然如果如下定义123var c=d=&#123;name:'阿Q'&#125;;// 或者var a=b=1; 这样的连等赋值，有另外的说法，之后专写一篇关于连等赋值的问题。 函数传参是按值传递还是引用传递对于这块内容，网上很多博文说法很多，还有说共享传递啥的，在此我们不对这些字面进行讨论，我们就解释下本质到底是怎么个情况。比如有如下代码123456var a = 1;function foo(x) &#123; x = 2;&#125;foo(a);console.log(a); // 仍为1, 未受x = 2赋值所影响 这个就无需多解释了，x作为一个形参，只在函数内部生效，而且当a当作参数传给x的时候，其实就是复制了一份a指向的栈内存中存放的值，所以a和x就是毫无关系了如果a为一个引用类型，如下代码123456var obj = &#123;x : 1&#125;;function foo(o) &#123; o.x = 3;&#125;foo(obj);console.log(obj.x); // 3, 被修改了! 此处也一样，x作为一个形参，当obj当作参数传给o的时候，其实是复制了一份obj指向的栈内存中存放的对象的地址，所以obj和o在栈内存中是不一样的，但在栈内存中存的东西是一样的，就是对象{x : 1}所在的地址；所以当修改o的时候，自然obj也就被修改了还有人提出以下代码123456var foo = &#123;name:'foo'&#125;;function test(o)&#123; o = &#123;name:'bar'&#125;; &#125;test(foo);console.log(foo.name); // foo，未被修改； 这个结果是没问题的，但这就是上文提到的对对象的修改的方式的问题，是直接赋值去修改变量，还是去修改对象的属性；上述代码foo当作参数传给o，同样将对象所在地址赋值一份给了形参o，但函数中o的赋值操作，使形参o完全指向了另外一个对象的内存地址，这个操作，并不影响实参foo在内存中存放的地址，及地址所指向的对象； 参考资料JS中函数的参数是按值传递还是按引用传递JavaScript参数按值传递的理解JS进阶系列之内存空间","categories":[],"tags":[]},{"title":"你不知道的JavaScript-第一部分","slug":"js中的作用域","date":"2018-08-22T12:08:24.000Z","updated":"2018-08-24T11:54:47.723Z","comments":true,"path":"2018/08/22/js中的作用域/","link":"","permalink":"http://iyue.top/2018/08/22/js中的作用域/","excerpt":"","text":"本文转自ZengTianShengZ，您可以直接去原处阅览 第一章： 作用域是什么1、 编译原理JavaScript 被列为 ‘动态’ 或 ‘解释执行’ 语言，于其他传统语言（如 java）不同的是，JavaScript是边编译边执行的。一段源码在执行前会经历三个步骤： 分词/词法分析 -&gt; 解析/语法分析 -&gt; 代码生成 分词/词法分析 这个过程将字符串分解成词法单元，如 var a = 2; 会被分解成词法单元 var、 a、 = 、2、;。空格一般没意义会被忽略 解析/语法分析 这个过程会将词法单元转换成 抽象语法树（Abstract Syntax Tree,AST）。如 var a = 2; 对应的 抽象语法树 如下, 可通过 在线可视化AST 网址在线分析 12345678910111213141516171819202122232425262728293031323334&#123; &quot;type&quot;: &quot;Program&quot;, &quot;start&quot;: 0, &quot;end&quot;: 10, &quot;body&quot;: [ &#123; &quot;type&quot;: &quot;VariableDeclaration&quot;, &quot;start&quot;: 0, &quot;end&quot;: 10, &quot;declarations&quot;: [ &#123; &quot;type&quot;: &quot;VariableDeclarator&quot;, &quot;start&quot;: 4, &quot;end&quot;: 9, &quot;id&quot;: &#123; &quot;type&quot;: &quot;Identifier&quot;, &quot;start&quot;: 4, &quot;end&quot;: 5, &quot;name&quot;: &quot;a&quot; &#125;, &quot;init&quot;: &#123; &quot;type&quot;: &quot;Literal&quot;, &quot;start&quot;: 8, &quot;end&quot;: 9, &quot;value&quot;: 2, &quot;raw&quot;: &quot;2&quot; &#125; &#125; ], &quot;kind&quot;: &quot;var&quot; &#125; ], &quot;sourceType&quot;: &quot;module&quot;&#125; 代码生成 将 AST 转换成可执行的代码，存放于内存中，并分配内存和转化为一些机器指令 2、理解作用域其实结合上面提到的编译原理，作用域就好理解了。作用域就是当前执行代码对这些标识符的访问权限。编译器会在当前作用域中声明一些变量，运行时引擎会去作用域中查找这些变量（其实就是一个寻址的过程），如果找到这些变量就可以操作变量，找不到就往上一层作用域找（作用域链的概念），或者返回 null 第三章： 函数作用域和块作用域1、函数中的作用域每声明一个函数都会形成一个作用域，那作用域有什么用呢，它能让该作用域内的变量和函数不被外界访问到，也可以反过来说是不让该作用域内的变量或函数污染全局。 对比：1234var a = 123function bar() &#123; //...&#125; 和123456function foo() &#123; var a = 123 function bar() &#123; //... &#125;&#125; 变量 a 和函数 bar 用一个函数 foo 包裹起来，函数 foo 会形成一个作用域，变量 a 和函数 bar 外界将无法访问，同时变量或函数也不会污染全局。 2、函数作用域进一步思考，上面例子的变量 a 和函数 bar 有了作用域，但函数 foo 不也是暴露在全局，也对全局造成污染了啊。是的，JavaScript对这种情况提出了解决方案： 立即执行函数 (IIFE) 123456(function foo() &#123; var a = 123 function bar() &#123; //... &#125;&#125;)() 第一个（）将函数变成表达式，第二个（）执行了这个函数，最终函数 foo 也形成了自己的作用域，不会污染到全局，同时也不被全局访问的到。 3、块作用域es6之前JavaScript是没有块作用域这个概念的，这与一般的语言（如Java ，C）很大不同，看下面这个例子： 1234for (var i = 0; i &lt; 10; i++) &#123; console.log(&apos;i=&apos;, i);&#125;console.log(&apos;输出&apos;, i); // 输出 10 for 循环定义了变量 i，通常我们只想这个变量 i 在循环内使用，但忽略了 i 其实是作用在外部作用域(函数或全局)的。所以循环过后也能正常打印出 i ,因为没有块的概念。 甚至连 try/catch 也没形成块作用域: 123456try &#123; for (var i = 0; i &lt; 10; i++) &#123; console.log(&apos;i=&apos;, i); &#125;&#125; catch (error) &#123;&#125;console.log(&apos;输出&apos;, i); // 输出 10 解决方法1 形成块作用域的方法当然是使用 es6 的 let 和 const 了， let 为其声明的变量隐式的劫持了所在的块作用域。 1234for (let i = 0; i &lt; 10; i++) &#123; console.log(&apos;i=&apos;, i);&#125;console.log(&apos;输出&apos;, i); // ReferenceError: i is not defined 将上面例子的 var 换成 let 最后输出就报错了 ReferenceError: i is not defined ，说明被 let 声明的 i 只作用在了 for 这个块中。 除了 let 会让 for、if、try/catch 等形成块，JavaScript 的 {} 也能形成块 12345&#123; let name = &apos;曾田生&apos;&#125;console.log(name); //ReferenceError: name is not defined 解决方法2 早在没 es6 的 let 声明之前，常用的做法是利用 函数也能形成作用域 这么个概念来解决一些问题的。 看个例子1234567891011121314function foo() &#123; var result = [] for (var i = 0; i &lt; 10; i++) &#123; result[i] = function () &#123; return i &#125; &#125; console.log(i）// i 作用在整个函数，for 执行完此时 i 已经等于 10 了 return result&#125;var result = foo()console.log(result[0]()); // 输出 10 期望 0console.log(result[1]()); // 输出 10 期望 1console.log(result[2]()); // 输出 10 期望 2 这个例子出现的问题是执行数组函数最终都输出了 10， 因为 i 作用在整个函数，for 执行完此时 i 已经等于 10 了, 所以当后续执行函数 result[x]() 内部返回的 i 已经是 10 了。 利用函数的作用域来解决 123456789101112131415function foo() &#123; var result = [] for (var i = 0; i &lt; 10; i++) &#123; result[i] = function (num) &#123; return function () &#123; // 函数形成一个作用域，内部变量被私有化了 return num &#125; &#125;(i) &#125; return result&#125;var result = foo()console.log(result[0]()); // 0console.log(result[1]()); // 1console.log(result[2]()); // 2 上面的例子也是挺典型的，一般面试题比较考基础的话就会被问道，上面例子不仅考察到了块作用域的概念，函数作用域的概念，还考察到了闭包的概念（闭包后续讲但不影响这个例子的理解），多琢磨一下就理解了。 第四章： 提升提升指的是变量提升和函数提升，为什么JavaScript会有提升这个概念呢，其实也很好理解，因为JavaScript代码是先 编译 后 执行 的，所以在编译阶段就会先对变量和函数做声明，在执行阶段就出现了所谓的变量提升和函数提升了。 1、变量提升12console.log(a); // undefinedvar a = 1; 上面代码 console.log(a); // undefined 就是因为编译阶段先对变量做了声明,先声明了个变量 a, 并默认赋值 undefined 123var a;console.log(a); // undefineda = 1; 2、函数提升函数同样也存在提升，这就是为什么函数能先调用后声明了 1234foo();function foo() &#123; console.log(&apos;---foo----&apos;);&#125; 注意:函数表达式不会被提升 12345foo();var foo = function() &#123; console.log(&apos;---foo----&apos;);&#125;// TypeError: foo is not a function 注意：函数会首先被提升，然后才是变量 123456var foo = 1;foo();function foo() &#123; console.log(&apos;---foo----&apos;);&#125;// TypeError: foo is not a function 分析一下，因为上面例子编译后是这样的 1234567var foo = undefined; // 变量名赋值 undefinedfunction foo() &#123; // 函数先提升 console.log(&apos;---foo----&apos;);&#125;foo = 1; // 但接下去是变量被重新赋值了 1，是个Number类型foo(); // Number类型当然不能用函数方式调用，就报错了// TypeError: foo is not a function 第五章： 作用域闭包闭包问题一直会在JavaScript被提起，是JavaScript一个比较奇葩的概念 1、闭包的产生 闭包的概念： 当函数可以记住并访问所在的词法作用域时，就产生了闭包 概念貌似挺简单的，简单分析下，首先闭包是 产生的，是在代码执行中产生的，有的一些网络博文直接将闭包定义为 某一个特殊函数 是错的。 闭包是怎么产生的呢，一个函数能访问到所在函数作用域就产生了闭包，注意到作用域的概念，咱们最上面的章节有提到，看下面例子： 12345678910111213function foo() &#123; var a = 0; function bar() &#123; a++; console.log(a); &#125; return bar;&#125;var bat = foo()bat() // 1bat() // 2bat() // 3 结合例子分析一下： 函数 foo 内部返回了函数 bar ,外部声明个变量 bat 拿到 foo 返回的函数 bar ，执行 bat() 发现能正常输出 1 ，注意前面章节提到的作用域，变量 a 是在函数 foo 内部的一个私有变量，不能被外界访问的，但外部函数 bat 却能访问的到私有变量 a，这说明了 外部函数 bat 持有函数 foo 的作用域 ，也就产生了闭包。 闭包的形成有什么用呢，JavaScript 让闭包的存在明显有它的作用，其中一个作用是为了模块化，当然你也可以利用外部函数持有另一个函数作用域的闭包特性去做更多的事情，但这边就暂且讨论模块化这个作用。 函数有什么作用呢，私有化变量\b或方法呀，那函数内的变量和方法被私有化了函数怎么和外部做 交流 呢, 暴露出一些变量或方法呀 123456789101112131415161718192021function foo() &#123; var _a = 0; var b = 0; function _add() &#123; b = _a + 10 &#125; function bar() &#123; _add() &#125; function getB() &#123; return b &#125; return &#123; bar: bar, getB: getB &#125;&#125;var bat = foo()bat.bar()bat.getB() // 10 上面例子函数 foo 可以理解为一个模块，内部声明了一些私有变量和方法，也对外界暴露了一些方法，只是在执行的过程中顺带产生了一个闭包 2、模块机制上面提到了闭包的产生和作用，貌似在使用 es6语法 开发的过程中很少用到了闭包，但实际上我们一直在用闭包的概念的。 foo.js 123456789101112131415var _a = 0;var b = 0;function _add() &#123; b = _a + 10&#125;function bar() &#123; _add()&#125;function getB() &#123; return b&#125;export default &#123; bar: bar, getB: getB&#125; bat.js 1234import bat from &apos;foo&apos;bat.bar()bat.getB() // 10 上面例子是 es6 模块的写法，是不是惊奇的发现变量 bat 可以记住并访问模块 foo 的作用域，这符合了闭包的概念。 小结：本章节我们深入理解了JavaScript的 作用域，提升，闭包等概念，希望你能有所收获，这也是我在读《你不知道的JavaScript·上卷》的一些体会。下一部分整理下 this解析、对象、原型 等一些概念。","categories":[],"tags":[{"name":"作用域","slug":"作用域","permalink":"http://iyue.top/tags/作用域/"}]},{"title":"将本地代码关联到远程仓库","slug":"将本地代码关联到远程仓库","date":"2018-08-16T06:28:57.000Z","updated":"2018-08-21T04:36:35.945Z","comments":true,"path":"2018/08/16/将本地代码关联到远程仓库/","link":"","permalink":"http://iyue.top/2018/08/16/将本地代码关联到远程仓库/","excerpt":"","text":"在项目的建立初期都是先搭建基础框架，在完成基础框架的搭建后，才把代码放到代码管理服务器上，让项目组成员进行检出从而进行需求的开发。而基础框架的搭建大部分都是先在个人的电脑上完成的，当完成框架搭建后，此时就要把代码共享到代码服务器上供开发人员检出。 准备工作本地安装git，在远程建有仓库，由于我们是将本地代码推到远程仓库，所以建远程仓库的时候不要进行初始化，即不必在仓库下添加任何文件，如readme.mdd等。 本地仓库初始化123git init // 初始化版本库git add . // 添加文件到版本库（只是添加到缓存区），.代表添加文件夹下所有文件 git commit -m \"first commit\" // 把添加的文件提交到版本库，并填写提交备注 关联推送123git remote add origin 你的远程库地址 // 把本地库与远程库关联git push -u origin master // 第一次推送时git push origin master // 第一次推送后，直接使用该命令即可推送修改 之后可能需要输入用户名密码，或者是ssh的形式。","categories":[],"tags":[{"name":"git","slug":"git","permalink":"http://iyue.top/tags/git/"}]},{"title":"vue中引入图片的方式","slug":"vue中引入图片的方式","date":"2018-08-16T06:11:14.000Z","updated":"2018-08-21T12:16:28.986Z","comments":true,"path":"2018/08/16/vue中引入图片的方式/","link":"","permalink":"http://iyue.top/2018/08/16/vue中引入图片的方式/","excerpt":"","text":"template和css中在 template 的 img 标签等和 css 的背景图中 1&lt;img class=\"logo-img\" src=\"~@/assets/logo/logo.png\" key=\"max-logo\" /&gt; 1background: url(~@/assets/dongdong.png) 4px 4px no-repeat; 其中‘~’为的是让 webpack 识别这是一个路径，‘@’表示 webpack 中配置的路径别名，此处表示 src 文件夹 在js中在 js 中作为变量引入时，需要以 require 的方式引入 123default_avatar() &#123; return require('@/assets/avatar/avatar_' + this.name.length % 10 + '.png')&#125; 此处引入不需要前面写‘~’ assets与static的区别 静态文件（主要指图片）均放在了src文件夹下的assets下，此处考虑到引入的资源都是属于项目本身的文件；此处的文件会被webpack的插件处理，如压缩，base64，hash等； static中应放置公共的类库等，如jQuery；此处的文件会直接复制到输出文件夹dist下的static中，不会被webpack处理；引入时直接以绝对路径引入即可。","categories":[],"tags":[{"name":"vue","slug":"vue","permalink":"http://iyue.top/tags/vue/"}]},{"title":"node在Windows下的安装与配置","slug":"node在Windows下的安装与配置","date":"2018-08-16T02:16:35.000Z","updated":"2018-08-16T02:37:34.704Z","comments":true,"path":"2018/08/16/node在Windows下的安装与配置/","link":"","permalink":"http://iyue.top/2018/08/16/node在Windows下的安装与配置/","excerpt":"","text":"安装在Windows下安装node很简单，直接取官网下载安装包，一路next就可以了，最新的安装包包含了npm，也会默认把node运行文件所在的目录添加到环境变量中。 当在终端执行node -v命令时，输出相应版本号说明安装成功。 配置npm默认的模块缓存路径及全局安装路径都在C盘，习惯上我们自行指定一个位置，一般会把node安装在D盘，相应的路径也设置在node目录下 在nodejs的目录下提前创建好两个文件夹node_global和node_cache 如下命令设置路径：12npm config set prefix \"D:\\\\nodejs\\\\node_global\"npm config set cache \"D:\\\\nodejs\\\\node_cache\" 设置完成后可通过npm config ls查看相关设置 此时需要将node_global路径加入到环境变量，这样保证终端可以找到全局安装的模块 注意有些教程里会指导将全局模块的路径直接设置在nodejs目录下1npm config set prefix \"D:\\\\nodejs\" 全局安装的模块会安装在node_modules下，和默认安装的npm在一起，命令文件就在nodejs下，这样就不需要再添加环境变量了 但这种做法会带来一个问题就是，无法通过npm un npm@lstest -g来升级npm模块，因为npm无法再升级安装的时候覆盖自己，而正常的npm升级是在全局模块的路径安装最新的npm，所以按照开头的路径设置，在node在会有两个npm，一个是默认安装的，一个是升级的时候安装在全局路径的。 所以还是建议全局路径设置另外的文件路径，并添加至环境变量。","categories":[],"tags":[{"name":"node","slug":"node","permalink":"http://iyue.top/tags/node/"}]},{"title":"css中如何使用wwebpack路径别名","slug":"css中如何使用wwebpack路径别名","date":"2018-08-12T05:59:32.000Z","updated":"2018-08-12T06:54:25.422Z","comments":true,"path":"2018/08/12/css中如何使用wwebpack路径别名/","link":"","permalink":"http://iyue.top/2018/08/12/css中如何使用wwebpack路径别名/","excerpt":"","text":"引言在用 Webpack 处理打包时，可将某一目录配置一个别名，代码中就能使用与别名的相对路径引用资源。在 Vue 项目中，我们通常使用 vue-webpack 脚手架生成工程模板，然后配置 @ 为项目根目录下放资源和源码的 /src 目录的别名。123456resolve: &#123; ..., alias: &#123; '@': resolve('src') &#125;&#125; 这样我们就可以在 js 中用导入模板文件或者js就可以用如下方式导入：1import tool from '@/style/xxx' 但是在样式文件（css/less/scss等）中，使用 @import “@/style/theme” 的语法引用相对 @ 的目录确会报错，“找不到 ‘@’ 目录”，说明 webpack 没有正确识别资源相对路径。 分析原因是 css 文件会被用 css-loader 处理，这里 css @import 后的字符串会被 css-loader 视为绝对路径解析，因为我们并没有添加 css-loader 的 alias，所以会报找不到 @ 目录。 解决在 Webpack 中 css import 使用 alias 相对路径的解决办法有两种； 方法一-添加模块路径直接为 css-loader 添加 ailas 的路径，但是在 vue-webpack 给的模板中，单独针对这个插件添加配置就显得麻烦冗余了；方法是：123456789// 添加配置modules: [ resolve('src'), resolve('node_modules') ],alias: &#123; 'vue$': 'vue/dist/vue.esm.js', '@': resolve('src'), &#125; 这样我们就可以在vue页面如下导入css文件1@import '~assets/css/all.scss'; // assets是src目录下的文件夹 方法二-添加‘~’符号是在引用路径的字符串最前面添加上 ~ 符号，如下1@import '~@/assets/css/all.scss'; // assets是src目录下的文件夹 Webpack 会将以 ~ 符号作为前缀的路径视作依赖模块而去解析，这样 @ 的 alias 配置就能生效了。 看起来还是方法二方便，不用配置webpack，直接使用。 总结~ 视为模块解析是 webpack 做的事，不是 css-loader 做的事。各类非 js 直接引用（import require）静态资源，依赖相对路径加载问题，都可以用 ~ 语法完美解决。123css module 中： @import \"~@/style/theme\"css 属性中： background: url(\"~@/assets/xxx.jpg\")html 标签中： &lt;img src=\"~@/assets/xxx.jpg\" alt=\"alias\"&gt;","categories":[{"name":"webpack","slug":"webpack","permalink":"http://iyue.top/categories/webpack/"}],"tags":[{"name":"webpack","slug":"webpack","permalink":"http://iyue.top/tags/webpack/"}]},{"title":"Hello World","slug":"hello-world","date":"2018-08-11T10:16:44.746Z","updated":"2018-08-11T10:16:44.746Z","comments":true,"path":"2018/08/11/hello-world/","link":"","permalink":"http://iyue.top/2018/08/11/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment test","categories":[],"tags":[]}]}